var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
console.log(a);
console.log(b);

非常感谢分享，在学习梳理的过程中，思考到了一个稍有不同的验证思路，大体上逻辑是相同的，个人也不保证完全正确，但是可以解释整个过程和结果。步骤如下：

1. var变量提升，全局活动对象上挂了a和b两个key，对应undefined，如下

GO = { a: undefined, b: undefined } // 这一步应该毫无异议

2. 检查没有其他函数声明，开始执行代码

    2-1 给 a 变量开辟一个新的内存空间，存储的是object类型，内含一个key, n, 此刻n本身是没有值，他只是一个索引key

    2-2 给这个n开辟了一个新的内存空间，存储的是数值类型 1，此刻 a 对应的是 { n: } 他本身是对象，
    或者说只是一个索引key的集合，本身没有包含任何其他数据类型，其中的 n 再去索引 数值为 1 的 这个内存空间,
    所以此刻 a 的值看起来就是 { n: 1 } // 但是 1 其实不在 a 直接对应的内存地址

3. 执行 a.x

    根据第二步的逻辑这就很好解释了，在 a 对应的内存空间新增一个 x 索引，准备赋值, 此刻 a 对应的空间变成  { n => 1, x: undefined }

4. 执行 a = { n: 2} 赋值

    使用第二部同样的逻辑可得，这一步，因为整个对象是新的了，内存就给a开了一个新的内存空间，这个空间的值是  { n: }
    然后给里面的 n 索引，又开辟了一个新的数值类型的空间，值为 2
    所以此刻 a 就变成了 { n => 2 } // 使用箭头为了表达他是索引到另外一个空间的
    
5. 执行 a.x 赋值

    重点来了！回头看第三步，我严重怀疑 （来自菜鸟的怀疑，大神可以指正真正的原理），在新增了x属性以后，内存操作的指针停留在了这个x，也就是a对应的那个 老内存地址内，
    做了赋值操作！ 所以 b 此刻也是索引到那个老地址的，那么看起来 b也就加了一个x！

